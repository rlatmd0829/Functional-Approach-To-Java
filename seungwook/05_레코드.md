# 레코드

레코드는 단순히 일반적인 자바 타입이나 기술을 의미하는 것이 아니라, 간단한 구문으로도 다양한 형태의 데이터를 집계할 수 있는 새로운 기능이다.

### 튜플

튜플에는 두가지 종류가 있다. 

구조적 튜플은 요소들의 순서에만 의존하므로 인덱스를 통해서만 접근이 가능하다.

명목상 튜플은 데이터에 접근하기 위한 방법으로 인덱스를 사용하지 않고 컴포넌트명을 사용한다.

## 도움을 주기 위한 레코드

레코드는 명목상 튜플과 마찬가지로, 순서대로 정렬된 값의 시퀀스를 집계하여 인덱스 대신 이름을 통해 데이터에 접근할 수 있다.

레코드의 등장으로 불필요한 보일러플레이트를 줄일 수 있게 되었다.

```java
public class User {
    private final String username;
    private final boolean active;
    private final LocalDateTime lastLogin;

    public User(String username, boolean active, LocalDateTime lastLogin) {
        this.username = username;
        this.active = active;
        this.lastLogin = lastLogin;
    }

    public String getUsername() {
        return username;
    }

    public boolean isActive() {
        return active;
    }

    public LocalDateTime getLastLogin() {
        return lastLogin;
    }

    @Override
    public boolean equals(Object o) {
        // ...
    }

    @Override
    public int hashCode() {
        // ...
    }

    @Override
    public String toString() {
        // ...
    }
}
```

```java
public record User(String username, boolean active, LocalDateTime lastLogin) {}
```

### 레코드의 특징

#### 컴포넌트 접근자

모든 레코드 컴포넌트는 private 필드로 저장되어 외부에서는 public 접근자 메서드를 통해서만 접근 가능하다.

이 접근자 메서드의 이름은 일반적인 getter의 접두사인 get 없이 해당 컴포넌트의 이름과 일치한다.

```java
public record User(String username, boolean active, LocalDateTime lastLogin) {}

var user = new User("seungwook", true, LocalDateTime.now());

var username = user.username();
```

#### 표준, 간결, 사용자 정의 생성자

레코드의 각 컴포넌트에 따라 자동으로 생성되는 생성자를 표준생성자 라고 부른다.

```java
public record User(String username, boolean active, LocalDateTime lastLogin) {
	public User(String username, boolean active, LocalDateTime lastLogin) {
		Object.requireNonNull(username);
		Object.requireNonNull(lastLogin);
        this.username = username;
        this.active = active;
        this.lastLogin = lastLogin;
    }
}
```

불필요한 보일러플레이트 코드를 반복하여 작성할 필요 없도록 간결(컴팩트) 생성자를 사용할 수 있다.

```java
public record User(String username, boolean active, LocalDateTime lastLogin) {
    public User {
        Object.requireNonNull(username);
        Object.requireNonNull(lastLogin);
		username = username.toUpperCase();
    }
}
```

#### 객체 식별과 설명

레코드는 데이터 동등성을 기반으로 하는 hashCode와 equals 메서드의 표준 구현을 제공한다.

2개의 객체 식별 메서드를 명시적으로 구현하지 않으면 레코드의 컴포넌트가 변경되더라도 코드를 업데이트할 필요가 없다.

레코드 타입의 두 인스턴스는 컴포넌트의 데이터가 동일하면 동일하다고 간주한다.

```java
User user1 = new User("john_doe", true, LocalDateTime.now());
User user2 = new User("john_doe", true, LocalDateTime.now());

System.out.println(user1.equals(user2)); // true
```

#### 어노테이션

username이 매개변수처럼 보이므로 ElementType.PARAMETER와 관련된 어노테이션만 가능해야 한다고 생각할 수 있지만, 레코드의 컴포넌트는 다양한 위치에 어노테이션을 적용할 수 있다.

```java
@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD})
public @interface MyAnnotation {
}
```

```java
public record User(@MyAnnotation String username, boolean active, LocalDateTime lastLogin) {
}
```

위 레코드 정의에서 @MyAnnotation 어노테이션이 username 컴포넌트에 적용했을경우 @MyAnnotation은 다음과 같이 각 위치에 전파된다.

- 필드: username 필드에 적용됩니다.
- 생성자 파라미터: username을 초기화하는 생성자의 파라미터에 적용됩니다.
- 게터 메서드: username() 게터 메서드에 적용됩니다.

#### 리플렉션

Java 16에서는 레코드 타입을 지원하기 위해 리플렉션 기능이 강화되었다. 레코드를 리플렉션으로 다룰 때 유용한 새로운 메서드와 기능이 추가되었다.

- Class.getRecordComponents() 메서드
  - 레코드 컴포넌트의 배열을 반환합니다. 레코드 컴포넌트는 레코드의 필드와 유사한 개념으로, 레코드를 정의할 때 지정된 구성 요소입니다.

- RecordComponent 클래스
  - 레코드 컴포넌트에 대한 메타데이터를 제공합니다. 예를 들어, 컴포넌트의 이름과 타입을 얻을 수 있습니다.



## 사용 사례와 일반적인 관행

### 레코드 유효성 검사 및 데이터 정제

